Application Tuning Part 1 - Developer
=========================
Tuning in isolation in single user mode

bind variables
--------------
without them can spend 90% of execution time parsing queries!
Oracle reuses Optimizer Plans where possible (SQL parsed and optimized here)
Searches SHARED POOL to see if SQL already exists
Using a variable name can implicitly use bind variables
e.g. insert into t (l_number) in a loop.
Don't forget cursor caching


hard parses
-----------




soft parses
-----------






Application Tuning Part 2 - Developer
=========================
Tuning in multi-user mode


Database instance/server Tuning - DBA
===============================




===
Program defensively with instrumentation


Tools
=====
SQL_TRACE			alter session set sql_trace=true. Writes to directory specified in init.ora by USER_DUMP_DEST : C:\APP\STEVE\PRODUCT\23AI\DBHOMEFREE\RDBMS\TRACE
					NB. This refers to the DB server's directory system - not Windows.
					
					SELECT value FROM v$diag_info WHERE name = 'Diag Trace'; -> C:\APP\STEVE\PRODUCT\23AI\diag\rdbms\free\free\trace
					
					SELECT s.sid, s.serial#, p.spid, t.tracefile
					FROM v$session s
					JOIN v$process p ON s.paddr = p.addr
					JOIN v$diag_info d ON d.name = 'Diag Trace'
					CROSS JOIN (
						SELECT p.spid,
								d.value || '/' || 'ora_' || p.spid || '.trc' tracefile
								FROM v$process p, v$diag_info d
								WHERE d.name = 'Diag Trace'
								) t
					WHERE s.audsid = USERENV('SESSIONID');
					sys.dbms_system.set_sql_trace_in_session. Need SID and SERIAL# available in V$SESSION
					
					found free_ora_18260.[trc&trm]
					
TIMED_STATISTICS	alter [session|system] set timed_statistics=true
TKPROF				formatter for raw SQL trace files generated by ALTER SESSION SET SQL_TRACE=TRUE
					post mortem vs active monitoring using dynamic performance views

Dynamic Performance Views
=========================
v$session_event
	Key columns: sid, event, total_waits, time_waited
	wait events experienced by each session. I/O, locks, latches
	
v$mystat
	Key columns: statistic#, value
	statistics for current session. Filtered version of v$sessstat.
	buffer gets, physical reads, CPU usage
	
v$sqlarea
	Key columns: sql_text, executions, buffer_gets, disk_reads, parse calls
	aggregated information about SQL statements
	
v$parameter
	Key columns: name, value, isdefault, ismodified
	values of initialization parameters for the running instance
	Useful for checkoing db config
	e.g. db_block_size, shared_pool_size, sessions etc
	
v$process
	Key columns: addr (process address - links to v$session.paddr, spid(OS process id), username(OS user), program
	
v$sessstat



Find session ‚Üí SQL ‚Üí process
SELECT s.sid,
       s.serial#,
       s.username,
       s.status,
       s.osuser,
       p.spid       AS os_pid,
       q.sql_id,
       q.sql_text
FROM   v$session s
JOIN   v$process p
       ON s.paddr = p.addr
LEFT JOIN v$sql q
       ON s.sql_id = q.sql_id
WHERE  s.username IS NOT NULL;


Alternative using V$SQLAREA (aggregated SQL)
SELECT s.sid,
       s.serial#,
       s.username,
       p.spid,
       a.sql_id,
       a.executions,
       a.buffer_gets,
       a.disk_reads,
       a.sql_text
FROM   v$session s
JOIN   v$process p
       ON s.paddr = p.addr
LEFT JOIN v$sqlarea a
       ON s.sql_id = a.sql_id
WHERE  s.username IS NOT NULL;


Find your own session (with V$MYSTAT)
SELECT s.sid,
       s.serial#,
       s.username,
       q.sql_text
FROM   v$session s
JOIN   v$mystat m
       ON s.sid = m.sid
LEFT JOIN v$sql q
       ON s.sql_id = q.sql_id
WHERE  s.audsid = USERENV('SESSIONID');


In short:

V$SESSION ‚Üî V$PROCESS = session-to-OS process mapping.
V$SESSION ‚Üî V$SQL/V$SQLAREA = session-to-SQL mapping.
Together, you know who is running what SQL on which OS process.


USERENV
one of Oracle‚Äôs built-in context functions that returns information about the current session environment.

legacy. Replaced with SYS_CONTEXT
SELECT SYS_CONTEXT('USERENV','SESSIONID') FROM dual;

Commonly Used Parameters
Parameter	What it Returns
'SESSIONID'	Auditing session ID (used in V$SESSION.AUDSID). Useful for identifying your session.
'TERMINAL'	The operating system terminal name for the session.
'LANGUAGE'	The language and territory settings of the session (NLS).
'ISDBA'	Returns 'TRUE' if the user has DBA privileges, otherwise 'FALSE'.
'CURRENT_USER'	The name of the current user (after proxy or definer rights).
'SESSION_USER'	The user who logged on.
'IP_ADDRESS'	The client‚Äôs IP address (for network sessions).
'HOST'	The name of the host machine where the session originated.




Example workflow
================
Step 1: Find the active sessions
SELECT sid, serial#, username, status, sql_id, event, blocking_session
FROM   v$session
WHERE  username IS NOT NULL
AND    status = 'ACTIVE';



Step 2: Get the SQL text
SELECT sql_id, sql_text
FROM   v$sql
WHERE  sql_id = '<SQL_ID from above>';


Step 3: Check OS process (if needed)
SELECT s.sid, s.serial#, p.spid AS os_pid
FROM   v$session s
JOIN   v$process p ON s.paddr = p.addr
WHERE  s.sid = <sid>;


Step 4: Enable SQL trace for that session
EXEC DBMS_MONITOR.SESSION_TRACE_ENABLE (
    session_id => <sid>,
    serial_num => <serial#>,
    waits      => TRUE,
    binds      => TRUE
);


Step 5: Let it run, then disable trace
EXEC DBMS_MONITOR.SESSION_TRACE_DISABLE (
    session_id => <sid>,
    serial_num => <serial#>
);


Step 6: Run TKPROF
tkprof tracefile.trc outputfile.prf sys=no sort=exeela


Step 7: Tune
From the TKPROF output you might discover:
The SQL is doing too many full table scans ‚Üí add an index.
The SQL is parsing too often ‚Üí add bind variables.
The SQL waits mostly on I/O ‚Üí consider partitioning, caching, or adjusting PCTFREE/PCTUSED.


Common Oracle Wait Events in TKPROF
===================================
1. db file sequential read
Meaning: Single-block read from disk (usually via an index lookup).
Good or Bad? Normal, but too many means maybe:
Index is not selective.
Too many index lookups instead of full scan.
Tuning: Check indexes, clustering, partitioning.


2. db file scattered read
Meaning: Multi-block read from disk (usually full table scan).
Good or Bad? Expected for large scans, but bad if on small tables.
Tuning: Add indexes, adjust optimizer statistics.


3. db file parallel read
Meaning: Multiple blocks read in parallel (e.g., during recovery, parallel query).
Tuning: Usually not an issue unless very frequent.


4. SQL*Net message from client
Meaning: Oracle is waiting for the client (application/user) to request the next fetch.
Good or Bad? Normal, usually indicates client-side slowness or ‚Äúthink time.‚Äù
Tuning: Not an Oracle issue.


5. SQL*Net more data from client
Meaning: Oracle waiting for more data to be sent from client (big inserts/LOBs).
Tuning: Usually application/network-related.


6. log file sync
Meaning: Session waiting for redo log flush after COMMIT.
Tuning:
Too many commits ‚Üí batch them.
Check redo log size / placement.


7. log file switch (checkpoint incomplete)
Meaning: Log switch couldn‚Äôt happen because checkpoint not finished.
Tuning: Increase redo log size / number.


8. latch free
Meaning: Contention on internal Oracle structures (latches).
Tuning: Investigate library cache or shared pool contention.


9. enq: TX - row lock contention
Meaning: Session waiting for another transaction to release a row lock.
Tuning: Check blocking session (V$SESSION.BLOCKING_SESSION).


10. buffer busy waits
Meaning: Multiple sessions trying to access the same block in memory.
Tuning: Hot block issue ‚Üí partitioning, spreading I/O, or schema redesign.


Summary for Interviews
Sequential read = single block (index lookup).
Scattered read = multi-block (full table scan).
SQL*Net message from client = client ‚Äúthink time.‚Äù
Log file sync = too many commits.
Row lock contention = blocking issues.




Oracle Blocks
Definition: The smallest unit of storage Oracle uses for data.
Size: Typically 8KB (but can be 2KB‚Äì32KB depending on DB block size).
Types:
Data blocks ‚Üí store table rows.
Index blocks ‚Üí store index entries.
Undo blocks ‚Üí store undo data for rollback.
Control/Redo blocks ‚Üí store metadata.

Key Idea:
When you query data, Oracle reads blocks (not rows!) into the buffer cache.
A single block can contain many rows.
üëâ Analogy: A block is like a page in a book. Oracle reads/writes whole pages, not just words.



Latches
Definition: A lightweight lock Oracle uses internally to protect shared memory structures (in the SGA).
Purpose: Prevents two sessions from modifying the same memory area at once.
Very short duration (microseconds‚Äìmilliseconds), unlike normal locks which can last until COMMIT/ROLLBACK.

Examples:
Library cache latch ‚Üí protects SQL & PL/SQL objects in shared pool.
Buffer cache latch ‚Üí protects access to data blocks in memory.
When they show up:

In TKPROF or AWR reports as "latch free" wait event.
Indicates contention ‚Üí too many processes fighting for the same latch.
üëâ Analogy: A latch is like a doorknob that only one person can turn at a time to enter a room. It prevents collisions, but you must release it quickly.



Latches vs. Locks in Oracle
1. Latches
Definition: Very low-level, short-term serialization mechanism.
Scope: Protects in-memory structures in the SGA (library cache, buffer cache, redo buffers).
Duration: Held for microseconds to milliseconds ‚Äî just long enough to safely update/read memory.
Type: Spinlock ‚Üí the process keeps trying until it gets the latch.
Granularity: Coarse (protects a whole structure, not individual rows).
Wait Event: "latch free".
Analogy: Like a doorknob that only one person can turn at a time to enter a room.

2. Locks
Definition: Higher-level concurrency control mechanism.
Scope: Protects database objects and rows (tables, rows, schema objects).
Duration: Can last for the whole transaction (until COMMIT/ROLLBACK).

Type: Can be shared, exclusive, or enqueue-based.
Granularity: Fine-grained (row-level, table-level, object-level).
Wait Event: "enq: TX - row lock contention" (row lock) or "enq: TM - contention" (table lock).
Analogy: Like a reserved seat in a library ‚Äî you hold it until you leave.




DBMS_PROFILER!!!


Instrumentation
===============
e.g. logging



Optimizer Plan Stability
========================
In many cases, the CBO finds better plans than a human hint would

Hints are still very relevant, but their role has shifted:

When Hints Are Useful:
	Stability: If the optimizer flips to a worse plan after stats change or upgrade, hints can ‚Äúlock in‚Äù a good plan.
	Complex queries: Sometimes the optimizer misses the best join order or access path; hints can guide it.
	Special cases: Parallelism, partition pruning, optimizer_features_enable control.
	Plan baselines/profiles: These are effectively ‚Äúmanaged hints.‚Äù

When Hints Are Bad:
	Used prematurely instead of fixing stats, schema design, or query logic.
	Can become outdated when data distribution changes, forcing bad plans.


SQL Plan Baselines
SQL Profiles

DBMS_APPLICATION_INFO (‚úÖ for performance monitoring)
DBMS_TRACE / DBMS_PROFILER (advanced)


Best Practice Recommendation
	For business/debug logging ‚Üí use a centralized logging package with a log table.
	For performance monitoring ‚Üí supplement with DBMS_APPLICATION_INFO.
	For debugging in dev ‚Üí DBMS_OUTPUT is fine.
	For deep profiling ‚Üí DBMS_PROFILER or third-party tools.

