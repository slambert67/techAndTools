<!DOCTYPE html>
<html>
<head>

  <meta charset="utf-8"/>
  <script src="jquery.js"></script>
  <script src="underscore.js"></script>
  <script src="backbone.js"></script>

<script>
$(document).ready(function(){
/*
The built-in capabilities of Models vary across frameworks; however, it's common for them to support validation of attributes, 
where attributes represent the properties of the Model, such as a Model identifier.

When using Models in real-world applications we generally also need a way of persisting Models. 
Persistence allows us to edit and update Models with the knowledge that their most recent states will be saved somewhere, 
for example in a web browser's localStorage data-store or synchronized with a database.

A Model may have multiple Views observing it for changes. By observing we mean that a View has registered an interest in being informed 
whenever an update is made to the Model. This allows the View to ensure that what is displayed on screen is kept in sync with the data 
contained in the model. Depending on your requirements, you might create a single View displaying all Model attributes, 
or create separate Views displaying different attributes. The important point is that the Model doesn't care how these Views are organized, 
it simply announces updates to its data as necessary through the framework's event system.

It is not uncommon for modern MVC/MV* frameworks to provide a means of grouping Models together. 
In Backbone, these groups are called Collections. Managing Models in groups allows us to write application logic 
based on notifications from the group when a Model within the group changes. This avoids the need to manually observe 
individual Model instances. We'll see this in action later in the book. Collections are also useful for performing 
any aggregate computations across more than one model.
*/

var Todo = Backbone.Model.extend({

  defaults : {
    title: 'Default title',
	completed: false
  },
  
  // initialize function optional
  initialize: function(){
      console.log('This model has been initialized.');
  }
});

// We can then create our own concrete instance of a (Todo) model
// with no values at all: Model may define optional defaults
var todo1 = new Todo();
// Following logs: {}
console.log(JSON.stringify(todo1));

// or with some arbitrary data:
var todo2 = new Todo({
  title: 'Check the attributes of both model instances in the console.',
  completed: true
});

// Following logs: {"title":"Check the attributes of both model instances in the console.","completed":true}
console.log(JSON.stringify(todo2));
  
});
</script>

</head>

<body>


  
</body>
</html>