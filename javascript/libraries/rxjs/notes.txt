Reactive Programming
- Paradigm that works with ASYNCHRONOUS DATA STREAMS

npm install rxjs
npm install @types/node
	

Asynchronous
============
Promises (native to javascript) or Observables (not native - RxJS library)

Think of Observable as a wrapper around an ordinary stream of data

Stream outputs/signals
- value
- error
- complete

Observables
- emit a function when stream returns value, error or complete

Observer is there to execute code when we receive a new value from observable

Observer subscribes to observable
Implements upto 3 methods
- next()
- error()
- complete()

It's the Observable that calls these methods

Observable has many methods to create an Observable from something eg. fromEvent

============
Resources
---------
https://reactivex.io/

An observer(subscriber,watcher,reactor) subscribes to an Observable. 
An Observable emits items or sends notifications to its observers by calling the observers’ methods

A “hot” Observable may begin emitting items as soon as it is created, and so any observer who later subscribes to that Observable may start observing the sequence somewhere in the middle
A “cold” Observable, on the other hand, waits until an observer subscribes to it before it begins to emit items, and so such an observer is guaranteed to see the whole sequence from the beginning.

https://github.com/ReactiveX/rxjs

https://rxjs.dev/

Observables
===========
Observables are like functions with zero arguments, but generalize those to allow multiple values.
Subscribing to an Observable is analogous to calling a Function
Observables are able to deliver values either synchronously or asynchronously.
What is the difference between an Observable and a function? Observables can "return" multiple values over time,

Creating
--------

create an observable
constructor takes a function that is executed when Observable initially subscribed to
this function is given (from where? - observer.subscribe) a Subscriber as it's 1st parameter
this is used (I think?) to define the outputs from the Observable

More commonly, created using functions e.g. of, from, interval etc


Subscribe
---------
While the Observer is the public API for consuming the values of an Observable, all Observers get converted to a Subscriber, 
in order to provide Subscription-like capabilities such as unsubscribe. Subscriber is a common type in RxJS, and crucial for implementing operators, but it is rarely used as a public API.


subscribe to myObservable
pass in an object that implements the Observer interface i.e. has next, error and complete functions defined
Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.
This is the moment the Observable starts it work
When you subscribe, you get back a Subscription, which represents the ongoing execution. Just call unsubscribe() to cancel the execution

func.call() means "give me one value synchronously"
observable.subscribe() means "give me any amount of values, either synchronously or asynchronously" 

It is not a coincidence that observable.subscribe and subscribe in new Observable(function subscribe(subscriber) {...}) have the same name. In the library, they are different, but for practical purposes you can consider them conceptually equal.
Subscribing to an Observable is like calling a function, providing callbacks where the data will be delivered to


e.g.
ob.subscribe({
    next(x) {console.log('got value ' + x);},
    error(err) {console.error('something wrong occurred: ' + err)},
    complete() {console.log('Observable has completed');}
});

subscribe is not a regular operator, but a method that calls Observable's INTERNAL subscribe function
- It might be for example a function that you passed to Observable's constructor
- but most of the time it is a library implementation, which defines what will be emitted by an Observable, and when it be will emitted.


Execute
-------
The code inside new Observable(function subscribe(subscriber) {...}) represents an "Observable execution"
a lazy computation that only happens for each Observer that subscribes
There are three types of values an Observable Execution can deliver:
- Next: notification: sends a value such as a Number, a String, an Object, etc.
- Error:  notification: sends a JavaScript Error or exception.
- Complete: notification: does not send a value
In an Observable Execution, zero to infinite Next notifications may be delivered. If either an Error or Complete notification is delivered, then nothing else can be delivered afterwards
It is a good idea to wrap any code in subscribe with try/catch block that will deliver an Error notification if it catches an exception:


Dispose
-------
Because Observable Executions may be infinite, and it's common for an Observer to want to abort execution in finite time, we need an API for canceling an execution. 
Since each execution is exclusive to one Observer only, once the Observer is done receiving values, it has to have a way to stop the execution, in order to avoid wasting computation power or memory resources.
When you subscribe, you get back a Subscription, which represents the ongoing execution. Just call unsubscribe() to cancel the execution

Each Observable must define how to dispose resources of that execution when we create the Observable using create(). You can do that by returning a custom unsubscribe function from within function subscribe().

const observable = new Observable(function subscribe(subscriber) {
  // Keep track of the interval resource
  const intervalId = setInterval(() => {
    subscriber.next('hi');
  }, 1000);
 
  // Provide a way of canceling and disposing the interval resource
  return function unsubscribe() {
    clearInterval(intervalId);
  };
});

Now look at Observer link at https://rxjs.dev/
